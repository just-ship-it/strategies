// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Howitzah

//@version=6
strategy("LDPS Scalper", overlay=true)

// ============================================================================
// INPUTS
// ============================================================================

// LDPS Signal Inputs (from external indicator)
ldps_is_bullish = input.source(title="LDPS Is Bullish", defval=close, group="LDPS Settings")
ldps_is_bearish = input.source(title="LDPS Is Bearish", defval=close, group="LDPS Settings")

// LT (Liquidity Trigger) Level Settings
lt_1 = input.source(title="LT Level 1", defval=close, group="LT Settings")
lt_2 = input.source(title="LT Level 2", defval=close, group="LT Settings")
lt_3 = input.source(title="LT Level 3", defval=close, group="LT Settings")
min_bullish_lt = input.int(title="Minimum Bullish LT Levels Required", defval=0, minval=0, maxval=3, group="LT Settings", tooltip="Number of LT levels that must be below current price (acting as support)")
min_bearish_lt = input.int(title="Minimum Bearish LT Levels Required", defval=0, minval=0, maxval=3, group="LT Settings", tooltip="Number of LT levels that must be above current price (acting as resistance)")

// Position Type Controls
allow_long = input.bool(true, title="Allow Long Trades", group="Position Control")
allow_short = input.bool(true, title="Allow Short Trades", group="Position Control")

// Trend Filter Settings
use_trend_filter = input.bool(false, title="Use Trend Filter", group="Trend Filter", tooltip="Only take trades in direction of overall trend")
trend_direction = input.source(title="Trend Direction", defval=close, group="Trend Filter", tooltip="1 = Bullish, 0 = Bearish from Trend Duration Forecast indicator")

// Short Filters (improve short trade selection)
use_volume_filter = input.bool(false, title="Enable Volume Filter", group="Short Filters", tooltip="Require minimum volume for short entries")
volume_multiplier = input.float(1.5, title="Volume Multiplier", minval=1.0, maxval=5.0, step=0.1, group="Short Filters", tooltip="Minimum volume as multiple of average (e.g., 1.5 = 50% above average)")
volume_period = input.int(20, title="Volume Lookback Period", minval=5, maxval=100, group="Short Filters", tooltip="Bars to calculate average volume")

use_resistance_filter = input.bool(false, title="Enable Resistance Proximity Filter", group="Short Filters", tooltip="Only allow shorts near recent resistance levels")
resistance_lookback = input.int(20, title="Resistance Lookback Period", minval=5, maxval=100, group="Short Filters", tooltip="Bars to look back for swing highs")
resistance_proximity = input.float(5.0, title="Resistance Proximity (Points)", minval=1.0, maxval=50.0, step=0.5, group="Short Filters", tooltip="Max distance from recent high to allow short")

// Scalp Target Settings
take_profit_points = input.int(title="Take Profit (Points)", defval=8, minval=1, maxval=50, group="Scalp Settings")
stop_loss_points = input.int(title="Stop Loss (Points)", defval=6, minval=1, maxval=50, group="Scalp Settings")
use_dynamic_stop = input.bool(false, title="Use Dynamic Stop Loss", group="Scalp Settings", tooltip="Use signal bar high/low as stop instead of fixed points")

// Trailing Stop Settings
use_trailing_stop = input.bool(false, title="Enable Trailing Stop", group="Trailing Stop")
trailing_trigger_points = input.float(title="Trailing Trigger (Points)", defval=5.0, minval=1, step=1, group="Trailing Stop", tooltip="Points in profit before trailing stop activates")
trailing_offset_points = input.float(title="Trailing Offset (Points)", defval=3.0, minval=1, step=1, group="Trailing Stop", tooltip="Points behind the peak price")

// Webhook Settings
webhook_secret = input.string(title="Webhook Secret", defval="", group="Webhook Settings", tooltip="Secret key for webhook authentication")

// ============================================================================
// LDPS SIGNAL PROCESSING
// ============================================================================

// Convert LDPS inputs to boolean values
is_bullish = ldps_is_bullish > 0
is_bearish = ldps_is_bearish > 0

// Convert trend direction to boolean (1 = bullish, 0 = bearish)
is_trend_bullish = trend_direction > 0.5

// Detect LDPS flips - simpler logic: just went from not-bullish to bullish (or vice versa)
ldps_flipped_bullish = is_bullish and not is_bullish[1]
ldps_flipped_bearish = is_bearish and not is_bearish[1]

// ============================================================================
// LT LEVEL ANALYSIS
// ============================================================================

// Store LT levels in array for easier processing
lt_levels = array.new<float>()
array.push(lt_levels, lt_1)
array.push(lt_levels, lt_2)
array.push(lt_levels, lt_3)

// Count bullish LT levels (those below current price acting as support)
bullish_lt_count = 0
for i = 0 to array.size(lt_levels) - 1
    level = array.get(lt_levels, i)
    if not na(level) and level < close
        bullish_lt_count += 1

// Count bearish LT levels (those above current price acting as resistance)
bearish_lt_count = 0
for i = 0 to array.size(lt_levels) - 1
    level = array.get(lt_levels, i)
    if not na(level) and level > close
        bearish_lt_count += 1

// Check if LT requirements are met
bullish_lt_requirement_met = bullish_lt_count >= min_bullish_lt
bearish_lt_requirement_met = bearish_lt_count >= min_bearish_lt

// Apply trend filter to LDPS signals
trend_filtered_bullish_flip = ldps_flipped_bullish and (not use_trend_filter or is_trend_bullish)
trend_filtered_bearish_flip = ldps_flipped_bearish and (not use_trend_filter or not is_trend_bullish)

// Apply position type controls
position_filtered_bullish_signal = trend_filtered_bullish_flip and allow_long
position_filtered_bearish_signal = trend_filtered_bearish_flip and allow_short

// Apply LT level requirements
lt_filtered_bullish_signal = position_filtered_bullish_signal and bullish_lt_requirement_met
lt_filtered_bearish_signal = position_filtered_bearish_signal and bearish_lt_requirement_met

// ============================================================================
// SHORT FILTERS (improve short trade selection)
// ============================================================================

// Volume filter - check if current volume meets minimum threshold
avg_volume = ta.sma(volume, volume_period)
volume_threshold_met = volume >= (avg_volume * volume_multiplier)
volume_filtered_bearish_signal = lt_filtered_bearish_signal and (not use_volume_filter or volume_threshold_met)

// Resistance proximity filter - check if close to recent swing high
highest_high = ta.highest(high, resistance_lookback)
distance_from_high = highest_high - close
near_resistance = distance_from_high <= resistance_proximity
resistance_filtered_bearish_signal = volume_filtered_bearish_signal and (not use_resistance_filter or near_resistance)

// Apply all filters
final_bullish_signal = lt_filtered_bullish_signal  // Longs with LT requirements
final_bearish_signal = resistance_filtered_bearish_signal  // Shorts with all filters

// ============================================================================
// STRATEGY EXECUTION
// ============================================================================

// Convert points to ticks (1 point = 4 ticks for NQ)
stop_ticks = stop_loss_points * 4
target_ticks = take_profit_points * 4
trailing_trigger_ticks = trailing_trigger_points * 4
trailing_offset_ticks = trailing_offset_points * 4

// Track dynamic stop levels
var float dynamic_long_stop = na
var float dynamic_short_stop = na

// Track pending limit orders
var int long_order_bar = na
var int short_order_bar = na

// Cancel unfilled limit orders after 1 bar
if not na(long_order_bar) and bar_index > long_order_bar
    strategy.cancel("Long")
    long_order_bar := na

if not na(short_order_bar) and bar_index > short_order_bar
    strategy.cancel("Short")
    short_order_bar := na

// Clear tracking when filled
if strategy.position_size > 0 and strategy.position_size[1] <= 0
    long_order_bar := na

if strategy.position_size < 0 and strategy.position_size[1] >= 0
    short_order_bar := na

// Track cancellations for visualization
var bool long_cancelled = false
var bool short_cancelled = false
long_cancelled := false
short_cancelled := false

// Only allow new entries when flat (no position flipping)
is_flat = strategy.position_size == 0

// Long entry on bullish flip - limit order at close
if final_bullish_signal and is_flat
    // Cancel any pending short order
    if not na(short_order_bar)
        strategy.cancel("Short")
        short_order_bar := na
        short_cancelled := true

    // Set dynamic stop level for long position
    dynamic_long_stop := low

    strategy.entry("Long", strategy.long, limit=close)
    long_order_bar := bar_index

    // Use dynamic stop if enabled, otherwise use fixed points
    if use_dynamic_stop
        if use_trailing_stop
            strategy.exit("Exit Long", "Long", stop=dynamic_long_stop, profit=target_ticks, trail_points=trailing_trigger_ticks, trail_offset=trailing_offset_ticks)
        else
            strategy.exit("Exit Long", "Long", stop=dynamic_long_stop, profit=target_ticks)
    else
        if use_trailing_stop
            strategy.exit("Exit Long", "Long", loss=stop_ticks, profit=target_ticks, trail_points=trailing_trigger_ticks, trail_offset=trailing_offset_ticks)
        else
            strategy.exit("Exit Long", "Long", loss=stop_ticks, profit=target_ticks)

// Short entry on bearish flip - limit order at close
if final_bearish_signal and is_flat
    // Cancel any pending long order
    if not na(long_order_bar)
        strategy.cancel("Long")
        long_order_bar := na
        long_cancelled := true

    // Set dynamic stop level for short position
    dynamic_short_stop := high

    strategy.entry("Short", strategy.short, limit=close)
    short_order_bar := bar_index

    // Use dynamic stop if enabled, otherwise use fixed points
    if use_dynamic_stop
        if use_trailing_stop
            strategy.exit("Exit Short", "Short", stop=dynamic_short_stop, profit=target_ticks, trail_points=trailing_trigger_ticks, trail_offset=trailing_offset_ticks)
        else
            strategy.exit("Exit Short", "Short", stop=dynamic_short_stop, profit=target_ticks)
    else
        if use_trailing_stop
            strategy.exit("Exit Short", "Short", loss=stop_ticks, profit=target_ticks, trail_points=trailing_trigger_ticks, trail_offset=trailing_offset_ticks)
        else
            strategy.exit("Exit Short", "Short", loss=stop_ticks, profit=target_ticks)

// Track expiration cancellations
var bool long_expired = false
var bool short_expired = false
long_expired := not na(long_order_bar[1]) and na(long_order_bar) and strategy.position_size <= 0
short_expired := not na(short_order_bar[1]) and na(short_order_bar) and strategy.position_size >= 0

// ============================================================================
// VISUALIZATION
// ============================================================================

// Show limit order placements
plotshape(final_bullish_signal, title="Long Limit Placed", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small, text="L")
plotshape(final_bearish_signal, title="Short Limit Placed", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, text="S")

// Show filtered signals
plotshape(ldps_flipped_bullish and not trend_filtered_bullish_flip, title="Long Filtered by Trend", style=shape.triangleup, location=location.belowbar, color=color.gray, size=size.tiny, text="Tf")
plotshape(ldps_flipped_bearish and not trend_filtered_bearish_flip, title="Short Filtered by Trend", style=shape.triangledown, location=location.abovebar, color=color.gray, size=size.tiny, text="Tf")
plotshape(position_filtered_bullish_signal and not lt_filtered_bullish_signal, title="Long Filtered by LT Levels", style=shape.triangleup, location=location.belowbar, color=color.blue, size=size.tiny, text="LTf")
plotshape(position_filtered_bearish_signal and not lt_filtered_bearish_signal, title="Short Filtered by LT Levels", style=shape.triangledown, location=location.abovebar, color=color.blue, size=size.tiny, text="LTf")
plotshape(trend_filtered_bullish_flip and not position_filtered_bullish_signal, title="Long Disabled", style=shape.triangleup, location=location.belowbar, color=color.yellow, size=size.tiny, text="Ld")
plotshape(lt_filtered_bearish_signal and not volume_filtered_bearish_signal, title="Short Filtered by Volume", style=shape.triangledown, location=location.abovebar, color=color.purple, size=size.tiny, text="Vf")
plotshape(volume_filtered_bearish_signal and not resistance_filtered_bearish_signal, title="Short Filtered by Resistance", style=shape.triangledown, location=location.abovebar, color=color.orange, size=size.tiny, text="Rf")
plotshape(trend_filtered_bearish_flip and not position_filtered_bearish_signal, title="Short Disabled", style=shape.triangledown, location=location.abovebar, color=color.yellow, size=size.tiny, text="Sd")

// Show cancellations (due to opposite signal)
plotshape(long_cancelled, title="Long Cancelled (Flip)", style=shape.xcross, location=location.belowbar, color=color.orange, size=size.small, text="Lx")
plotshape(short_cancelled, title="Short Cancelled (Flip)", style=shape.xcross, location=location.abovebar, color=color.orange, size=size.small, text="Sx")

// Show expirations (unfilled after 1 bar)
plotshape(long_expired, title="Long Expired", style=shape.xcross, location=location.belowbar, color=color.gray, size=size.tiny)
plotshape(short_expired, title="Short Expired", style=shape.xcross, location=location.abovebar, color=color.gray, size=size.tiny)

// ============================================================================
// DATA WINDOW TRACKING
// ============================================================================

plotchar(is_bullish ? 1 : 0, title="LDPS Bullish", char=" ", location=location.top, display=display.data_window)
plotchar(is_bearish ? 1 : 0, title="LDPS Bearish", char=" ", location=location.top, display=display.data_window)
plotchar(is_trend_bullish ? 1 : 0, title="Trend Bullish", char=" ", location=location.top, display=display.data_window)
plotchar(bullish_lt_count, title="Bullish LT Count", char=" ", location=location.top, display=display.data_window)
plotchar(bearish_lt_count, title="Bearish LT Count", char=" ", location=location.top, display=display.data_window)
plotchar(min_bullish_lt, title="Min Bullish LT Required", char=" ", location=location.top, display=display.data_window)
plotchar(min_bearish_lt, title="Min Bearish LT Required", char=" ", location=location.top, display=display.data_window)
plotchar(bullish_lt_requirement_met ? 1 : 0, title="Bullish LT Requirement Met", char=" ", location=location.top, display=display.data_window)
plotchar(bearish_lt_requirement_met ? 1 : 0, title="Bearish LT Requirement Met", char=" ", location=location.top, display=display.data_window)
plotchar(volume_threshold_met ? 1 : 0, title="Volume Threshold Met", char=" ", location=location.top, display=display.data_window)
plotchar(near_resistance ? 1 : 0, title="Near Resistance", char=" ", location=location.top, display=display.data_window)

// ============================================================================
// ALERTS
// ============================================================================

// Track alert conditions
long_limit_placed = final_bullish_signal and is_flat
short_limit_placed = final_bearish_signal and is_flat

// Calculate prices for alerts
long_limit_price = close
long_stop_price = use_dynamic_stop ? dynamic_long_stop : close - stop_loss_points
long_target_price = close + take_profit_points

short_limit_price = close
short_stop_price = use_dynamic_stop ? dynamic_short_stop : close + stop_loss_points
short_target_price = close - take_profit_points

// Cancel signals
long_cancel_signal = long_expired or long_cancelled
short_cancel_signal = short_expired or short_cancelled

// Position closed signals
long_position_closed = strategy.position_size == 0 and strategy.position_size[1] > 0
short_position_closed = strategy.position_size == 0 and strategy.position_size[1] < 0

// Long limit order alert
if long_limit_placed
    if use_trailing_stop
        alert('{"webhook_type": "trade_signal", "secret": "' + webhook_secret + '", "action": "place_limit", "side": "buy", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(long_limit_price) + ', "stop_loss": ' + str.tostring(long_stop_price) + ', "take_profit": ' + str.tostring(long_target_price) + ', "trailing_trigger": ' + str.tostring(trailing_trigger_points) + ', "trailing_offset": ' + str.tostring(trailing_offset_points) + ', "quantity": 1, "strategy": "LDPS_Scalper"}', alert.freq_once_per_bar)
    else
        alert('{"webhook_type": "trade_signal", "secret": "' + webhook_secret + '", "action": "place_limit", "side": "buy", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(long_limit_price) + ', "stop_loss": ' + str.tostring(long_stop_price) + ', "take_profit": ' + str.tostring(long_target_price) + ', "quantity": 1, "strategy": "LDPS_Scalper"}', alert.freq_once_per_bar)

// Short limit order alert
if short_limit_placed
    if use_trailing_stop
        alert('{"webhook_type": "trade_signal", "secret": "' + webhook_secret + '", "action": "place_limit", "side": "sell", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(short_limit_price) + ', "stop_loss": ' + str.tostring(short_stop_price) + ', "take_profit": ' + str.tostring(short_target_price) + ', "trailing_trigger": ' + str.tostring(trailing_trigger_points) + ', "trailing_offset": ' + str.tostring(trailing_offset_points) + ', "quantity": 1, "strategy": "LDPS_Scalper"}', alert.freq_once_per_bar)
    else
        alert('{"webhook_type": "trade_signal", "secret": "' + webhook_secret + '", "action": "place_limit", "side": "sell", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(short_limit_price) + ', "stop_loss": ' + str.tostring(short_stop_price) + ', "take_profit": ' + str.tostring(short_target_price) + ', "quantity": 1, "strategy": "LDPS_Scalper"}', alert.freq_once_per_bar)

// Cancel alerts
if long_cancel_signal
    cancel_reason = long_expired ? "expired" : "cancelled"
    alert('{"webhook_type": "trade_signal", "secret": "' + webhook_secret + '", "action": "cancel_limit", "side": "buy", "symbol": "' + syminfo.ticker + '", "reason": "' + cancel_reason + '", "quantity": 1, "strategy": "LDPS_Scalper"}', alert.freq_once_per_bar)

if short_cancel_signal
    cancel_reason = short_expired ? "expired" : "cancelled"
    alert('{"webhook_type": "trade_signal", "secret": "' + webhook_secret + '", "action": "cancel_limit", "side": "sell", "symbol": "' + syminfo.ticker + '", "reason": "' + cancel_reason + '", "quantity": 1, "strategy": "LDPS_Scalper"}', alert.freq_once_per_bar)

// Position closed alerts
if long_position_closed
    alert('{"webhook_type": "trade_signal", "secret": "' + webhook_secret + '", "action": "position_closed", "side": "long", "symbol": "' + syminfo.ticker + '", "exit_price": ' + str.tostring(close) + ', "strategy": "LDPS_Scalper"}', alert.freq_once_per_bar)

if short_position_closed
    alert('{"webhook_type": "trade_signal", "secret": "' + webhook_secret + '", "action": "position_closed", "side": "short", "symbol": "' + syminfo.ticker + '", "exit_price": ' + str.tostring(close) + ', "strategy": "LDPS_Scalper"}', alert.freq_once_per_bar)
